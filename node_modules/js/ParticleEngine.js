/**
* @author Lee Stemkoski   http://www.adelphi.edu/~stemkoski/
*/

/*****************************START ADDED CODE***************/
import { AdditiveBlending, BufferAttribute, BufferGeometry, Color, Mesh, NormalBlending, Points, PointsMaterial, ShaderMaterial, Texture, TextureLoader, Vector3 } from 'three';

const THREE = require('three');
/*****************************FINISH ADDED CODE**************/
/////////////
// SHADERS //
/////////////

// attribute: data that may be different for each particle (such as size and color);
//      can only be used in vertex shader
// varying: used to communicate data from vertex shader to fragment shader
// uniform: data that is the same for each particle (such as texture)


var particleVertexShader = [
"attribute vec3  customColor;",
"attribute float customOpacity;",
"attribute float customSize;",
"attribute float customAngle;",
"attribute float customVisible;",  // float used as boolean (0 = false, 1 = true)
"varying vec4  vColor;",
"varying float vAngle;",
"void main()",
"{",
	"if ( customVisible > 0.5 )", 				// true
		"vColor = vec4( customColor, customOpacity );", //     set color associated to vertex; use later in fragment shader.
	"else",							// false
		"vColor = vec4(255, 255, 255, 1);", 		//     make particle invisible.
		
	"vAngle = customAngle;",

	"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	"gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );",     // scale particles as objects in 3D space
	"gl_Position = projectionMatrix * mvPosition;",
"}"
].join("\n");

var particleFragmentShader =[ "uniform sampler2D texture;",
"varying vec4 vColor;", 	
"varying float vAngle;",   
"void main()", 
"{",
	"gl_FragColor = vColor;",
	
	"float c = cos(vAngle);",
	"float s = sin(vAngle);",
	"vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,", 
	                      "c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);",  // rotate UV coordinates to rotate texture
    	"vec4 rotatedTexture = texture2D( texture,  rotatedUV );",
	"gl_FragColor = gl_FragColor * rotatedTexture;",    // sets an otherwise white particle texture to desired color
"}"
].join("\n");

///////////////////////////////////////////////////////////////////////////////

/////////////////
// TWEEN CLASS //
/////////////////

function Tween(timeArray, valueArray)
{
	this.times  = timeArray || [];
	this.values = valueArray || [];
}

Tween.prototype.lerp = function(t)
{
	var i = 0;
	var n = this.times.length;
	while (i < n && t > this.times[i])  
		i++;
	if (i == 0) return this.values[0];
	if (i == n)	return this.values[n-1];
	var p = (t - this.times[i-1]) / (this.times[i] - this.times[i-1]);
	if (this.values[0] instanceof Vector3)
		return this.values[i-1].clone().lerp( this.values[i], p );
	else // its a float
		return this.values[i-1] + p * (this.values[i] - this.values[i-1]);
}

///////////////////////////////////////////////////////////////////////////////

////////////////////
// PARTICLE CLASS //
////////////////////

function Particle()
{
	this.position     = new Vector3();
	this.velocity     = new Vector3(); // units per second
	this.acceleration = new Vector3();

	this.angle             = 0;
	this.angleVelocity     = 0; // degrees per second
	this.angleAcceleration = 0; // degrees per second, per second
	
	this.size = 16.0;

	this.color   = new Color ();
	this.opacity = 1.0;
			
	this.age   = 0;
	this.alive = 0; // use float instead of boolean for shader purposes	
}

Particle.prototype.update = function(dt)
{
	this.position.add( this.velocity.clone().multiplyScalar(dt) );
	this.velocity.add( this.acceleration.clone().multiplyScalar(dt) );
	
	// convert from degrees to radians: 0.01745329251 = Math.PI/180
	this.angle         += this.angleVelocity     * 0.01745329251 * dt;
	this.angleVelocity += this.angleAcceleration * 0.01745329251 * dt;

	this.age += dt;
	
	// if the tween for a given attribute is nonempty,
	//  then use it to update the attribute's value

	if ( this.sizeTween.times.length > 0 )
		this.size = this.sizeTween.lerp( this.age );
				
	if ( this.colorTween.times.length > 0 )
	{
		var colorHSL = this.colorTween.lerp( this.age );
		this.color = new Color().setHSL( colorHSL.x, colorHSL.y, colorHSL.z );
	}
	
	if ( this.opacityTween.times.length > 0 )
		this.opacity = this.opacityTween.lerp( this.age );
}
	
///////////////////////////////////////////////////////////////////////////////

///////////////////////////
// PARTICLE ENGINE CLASS //
///////////////////////////

var Type = Object.freeze({ "CUBE":1, "SPHERE":2 });


class ParticleEngine
{
	/////////////////////////
	// PARTICLE PROPERTIES //
	/////////////////////////
	constructor() {
	
		this.positionStyle = Type.CUBE;		
		this.positionBase   = new Vector3();
		// cube shape data
		this.positionSpread = new Vector3();
		// sphere shape data
		this.positionRadius = 0; // distance from base at which particles start
		
		this.velocityStyle = Type.CUBE;	
		// cube movement data
		this.velocityBase       = new Vector3();
		this.velocitySpread     = new Vector3(); 
		// sphere movement data
		//   direction vector calculated using initial position
		this.speedBase   = 0;
		this.speedSpread = 0;
		
		this.accelerationBase   = new Vector3();
		this.accelerationSpread = new Vector3();	
		
		this.angleBase               = 0;
		this.angleSpread             = 0;
		this.angleVelocityBase       = 0;
		this.angleVelocitySpread     = 0;
		this.angleAccelerationBase   = 0;
		this.angleAccelerationSpread = 0;
		
		this.sizeBase   = 0.0;
		this.sizeSpread = 0.0;
		this.sizeTween  = new Tween();
				
		// store colors in HSL format in a Vector3 object
		// http://en.wikipedia.org/wiki/HSL_and_HSV
		this.colorBase   = new Vector3(0.0, 1.0, 0.5); 
		this.colorSpread = new Vector3(0.0, 0.0, 0.0);
		this.colorTween  = new Tween();
		
		this.opacityBase   = 1.0;
		this.opacitySpread = 0.0;
		this.opacityTween  = new Tween();

		this.blendStyle = NormalBlending; // false;

		this.particleArray = [];
		this.particlesPerSecond = 100;
		this.particleDeathAge = 1.0;
		
		////////////////////////
		// EMITTER PROPERTIES //
		////////////////////////
		
		this.emitterAge      = 0.0;
		this.emitterAlive    = true;
		this.emitterDeathAge = 60; // time (seconds) at which to stop creating particles.
		
		// How many particles could be active at any time?
		this.particleCount = this.particlesPerSecond * Math.min( this.particleDeathAge, this.emitterDeathAge );

		//////////////
		// THREE.JS //
		//////////////
	
		
        /*****************************START ADDED CODE***************/
       /* this.particleGeometry=  new BufferGeometry();
		this.customVisible=	{ type: 'f',  value: [] }; 
		this.customAngle=	{ type: 'f',  value: [] };
		this.customSize=		{ type: 'f',  value: [] };
		this.customColor=	{ type: 'c',  value: [] };
		this.customOpacity=	{ type: 'f',  value: [] };
	
		this.particleGeometry.setAttribute('position', new BufferAttribute(new Float32Array(this.particleCount), 3));
		this.particleGeometry.setAttribute('customVisible', new BufferAttribute(this.customVisible, 1));
		this.particleGeometry.setAttribute('customAngle', new BufferAttribute(this.customAngle, 1));
		this.particleGeometry.setAttribute('customSize', new BufferAttribute(this.customSize, 1));
		this.particleGeometry.setAttribute('customColor', new BufferAttribute(this.customColor, 3));
		this.particleGeometry.setAttribute('customOpacity', new BufferAttribute(this.customOpacity, 1));
	   */		this.particleGeometry = new THREE.BufferGeometry();

		this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.particleCount), 3));
		this.particleGeometry.setAttribute('customVisible', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customAngle', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customSize', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customColor', new THREE.BufferAttribute(new Float32Array(this.particleCount), 3));
		this.particleGeometry.setAttribute('customOpacity', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));

		/*****************************FINISH ADDED CODE**************/
        /*****************************START COMMENTED CODE***************/
     /*
        this.particleGeometry = new THREE.Geometry();
     */
        /*****************************FINISH COMMENTED CODE**************/
	
		this.particleTexture  = null;
		this.particleMaterial = new ShaderMaterial( 
		{
			uniforms: 
			{
				texture:   { type: "t", value: this.particleTexture },
			},
          
                 /*****************************START COMMENTED CODE***************/
                 /*
                          attributes:     
                        {
                            customVisible:	{ type: 'f',  value: [] },
                            customAngle:	{ type: 'f',  value: [] },
                            customSize:		{ type: 'f',  value: [] },
                            customColor:	{ type: 'c',  value: [] },
                            customOpacity:	{ type: 'f',  value: [] }
                        },
                 */
                 /*****************************FINISH COMMENTED CODE**************/

			vertexShader:   particleVertexShader,
			fragmentShader: particleFragmentShader,
			transparent: false, // alphaTest: 0.5,  // if having transparency issues, try including: alphaTest: 0.5, 
			blending: NormalBlending, depthTest: true,
			
		});

		this.particleMesh = new Mesh();
	}
	
}
	
ParticleEngine.prototype.setValues = function( parameters )
{
	if ( parameters === undefined ) return;
	
	// clear any previous tweens that might exist
	this.sizeTween    = new Tween();
	this.colorTween   = new Tween();
	this.opacityTween = new Tween();
	
	for ( var key in parameters ) 
		this[ key ] = parameters[ key ];
	
	// attach tweens to particles
	Particle.prototype.sizeTween    = this.sizeTween;
	Particle.prototype.colorTween   = this.colorTween;
	Particle.prototype.opacityTween = this.opacityTween;	
	
	// calculate/set derived particle engine values
	this.particleArray = [];
	this.emitterAge      = 0.0;
	this.emitterAlive    = true;
	this.particleCount = this.particlesPerSecond * Math.min( this.particleDeathAge, this.emitterDeathAge );
	
		
        /*****************************START ADDED CODE***************/
       /* this.particleGeometry=  new BufferGeometry();
		this.customVisible=	{ type: 'f',  value: [] }; 
		this.customAngle=	{ type: 'f',  value: [] };
		this.customSize=		{ type: 'f',  value: [] };
		this.customColor=	{ type: 'c',  value: [] };
		this.customOpacity=	{ type: 'f',  value: [] };
	
		this.particleGeometry.setAttribute('position', new BufferAttribute(new Float32Array(this.particleCount*3), 3));
		this.particleGeometry.setAttribute('customVisible', new BufferAttribute(this.customVisible, 1));
		this.particleGeometry.setAttribute('customAngle', new BufferAttribute(this.customAngle, 1));
		this.particleGeometry.setAttribute('customSize', new BufferAttribute(this.customSize, 1));
		this.particleGeometry.setAttribute('customColor', new BufferAttribute(this.customColor, 3));
		this.particleGeometry.setAttribute('customOpacity', new BufferAttribute(this.customOpacity, 1));
		*/
		this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.particleCount * 3), 3));
		this.particleGeometry.setAttribute('customVisible', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customAngle', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customSize', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		this.particleGeometry.setAttribute('customColor', new THREE.BufferAttribute(new Float32Array(this.particleCount * 3), 3));
		this.particleGeometry.setAttribute('customOpacity', new THREE.BufferAttribute(new Float32Array(this.particleCount), 1));
		/*****************************FINISH ADDED CODE**************/
        /*****************************START COMMENTED CODE***************/
     /*
        this.particleGeometry = new THREE.Geometry();
     */
        /*****************************FINISH COMMENTED CODE**************/
	
	this.particleMaterial = new ShaderMaterial( 
	{
		uniforms: 
		{
			texture:   { type: "t", value: this.particleTexture },
		},   /*****************************START COMMENTED CODE***************/
                 /*
                          attributes:     
                        {
                            customVisible:	{ type: 'f',  value: [] },
                            customAngle:	{ type: 'f',  value: [] },
                            customSize:		{ type: 'f',  value: [] },
                            customColor:	{ type: 'c',  value: [] },
                            customOpacity:	{ type: 'f',  value: [] }
                        },
                 */
                 /*****************************FINISH COMMENTED CODE**************/

		vertexShader:   particleVertexShader,
		fragmentShader: particleFragmentShader,
		transparent: false, // alphaTest: 0.5, // if having transparency issues, try including: alphaTest: 0.5, 
		blending: NormalBlending, depthTest: true
	});
	this.particleMesh = new Points();// CHANGED --> this.particleMesh = new THREE.ParticleSystem();
}
	
// helper functions for randomization
ParticleEngine.prototype.randomValue = function(base, spread)
{
	return base + spread * (Math.random() - 0.5);
}
ParticleEngine.prototype.randomVector3 = function(base, spread)
{
	var rand3 = new Vector3( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );
	return new Vector3().addVectors( base, new Vector3().multiplyVectors( spread, rand3 ) );
}


ParticleEngine.prototype.createParticle = function()
{
	var particle = new Particle();

	if (this.positionStyle == Type.CUBE)
		particle.position = this.randomVector3( this.positionBase, this.positionSpread ); 
	if (this.positionStyle == Type.SPHERE)
	{
		var z = 2 * Math.random() - 1;
		var t = 6.2832 * Math.random();
		var r = Math.sqrt( 1 - z*z );
		var vec3 = new Vector3( r * Math.cos(t), r * Math.sin(t), z );
		particle.position = new Vector3().addVectors( this.positionBase, vec3.multiplyScalar( this.positionRadius ) );
	}
		
	if ( this.velocityStyle == Type.CUBE )
	{
		particle.velocity     = this.randomVector3( this.velocityBase,     this.velocitySpread ); 
	}
	if ( this.velocityStyle == Type.SPHERE )
	{
		var direction = new Vector3().subVectors( particle.position, this.positionBase );
		var speed     = this.randomValue( this.speedBase, this.speedSpread );
		particle.velocity  = direction.normalize().multiplyScalar( speed );
	}
	
	particle.acceleration = this.randomVector3( this.accelerationBase, this.accelerationSpread ); 

	particle.angle             = this.randomValue( this.angleBase,             this.angleSpread );
	particle.angleVelocity     = this.randomValue( this.angleVelocityBase,     this.angleVelocitySpread );
	particle.angleAcceleration = this.randomValue( this.angleAccelerationBase, this.angleAccelerationSpread );

	particle.size = this.randomValue( this.sizeBase, this.sizeSpread );

	var color = this.randomVector3( this.colorBase, this.colorSpread );
	particle.color = new Color().setHSL( color.x, color.y, color.z );
	
	particle.opacity = this.randomValue( this.opacityBase, this.opacitySpread );

	particle.age   = 0;
	particle.alive = 0; // particles initialize as inactive
	
	return particle;
}

ParticleEngine.prototype.initialize = function(scene)
{
	// link particle data with geometry/material data
	for (var i = 0; i < this.particleCount; i++)
	{
		
	
     /*****************************START COMMENTED CODE***************/
     /*
        // remove duplicate code somehow, here and in update function below.
		this.particleArray[i] = this.createParticle();
		this.particleGeometry.vertices[i] = this.particleArray[i].position;
		this.particleMaterial.attributes.customVisible.value[i] = this.particleArray[i].alive;
		this.particleMaterial.attributes.customColor.value[i]   = this.particleArray[i].color;
		this.particleMaterial.attributes.customOpacity.value[i] = this.particleArray[i].opacity;
		this.particleMaterial.attributes.customSize.value[i]    = this.particleArray[i].size;
		this.particleMaterial.attributes.customAngle.value[i]   = this.particleArray[i].angle;
     */
     /*****************************FINISH COMMENTED CODE**************/
        /*****************************START ADDED CODE***************/
      /*  this.particleArray[i] = this.createParticle();

        this.customVisible.value[i]=  this.particleArray[i].alive; 
        this.customAngle.value[i]=  this.particleArray[i].angle;
        this.customSize.value[i]=  this.particleArray[i].size;
        this.customColor.value[i]=  this.particleArray[i].color;
        this.customOpacity.value[i]=  this.particleArray[i].opacity;
	
		
		this.particleGeometry.attributes.position.array[(i*3)] =this.particleArray[i].position.x;
		this.particleGeometry.attributes.position.array[(i*3) + 1] =this.particleArray[i].position.y;
		this.particleGeometry.attributes.position.array[(i*3) + 2] =this.particleArray[i].position.z;
		
	
	
		this.particleGeometry.setAttribute('customVisible'+i, new BufferAttribute(this.customVisible.value[i], 1));
		this.particleGeometry.setAttribute('customAngle'+i, new BufferAttribute(this.customAngle.value[i], 1));
		this.particleGeometry.setAttribute('customSize'+i, new BufferAttribute(this.customSize.value[i], 1));
		this.particleGeometry.setAttribute('customColor'+i, new BufferAttribute(this.customColor.value[i], 3));
		this.particleGeometry.setAttribute('customOpacity'+i, new BufferAttribute(this.customOpacity.value[i], 1));
*/
this.particleArray[i] = this.createParticle();

this.particleGeometry.attributes.position.array[(i*3)] =this.particleArray[i].position.x;
this.particleGeometry.attributes.position.array[(i*3) + 1] =this.particleArray[i].position.y;
this.particleGeometry.attributes.position.array[(i*3) + 2] =this.particleArray[i].position.z;


this.particleGeometry.attributes.customVisible.array[i] = this.particleArray[i].alive;


this.particleGeometry.attributes.customColor.array[(i*3)]= this.particleArray[i].color.r;
this.particleGeometry.attributes.customColor.array[(i*3)+ 1]= this.particleArray[i].color.g;
this.particleGeometry.attributes.customColor.array[(i*3)+ 2]= this.particleArray[i].color.b;


this.particleGeometry.attributes.customOpacity.array[i] = this.particleArray[i].opacity;

this.particleGeometry.attributes.customSize.array[i]    = this.particleArray[i].size;
this.particleGeometry.attributes.customAngle.array[i]   = this.particleArray[i].angle;
     /*****************************FINISH ADDED CODE**************/
 
	}
	
	this.particleMaterial.blending = this.blendStyle;
	if ( this.blendStyle !=NormalBlending) 
		this.particleMaterial.depthTest = false;
	
	this.particleMesh = new Points( this.particleGeometry, this.particleMaterial ); //CHANGED -->this.particleMesh = new THREE.ParticleSystem( this.particleGeometry, this.particleMaterial );
	this.particleMesh.dynamic = true;
	this.particleMesh.sortParticles = true;



	scene.add( this.particleMesh );
}

ParticleEngine.prototype.update = function(dt)
{
	var recycleIndices = [];
	
	// update particle data
	for (var i = 0; i < this.particleCount; i++)
	{
		if ( this.particleArray[i].alive )
		{
			this.particleArray[i].update(dt);

			// check if particle should expire
			// could also use: death by size<0 or alpha<0.
			if ( this.particleArray[i].age > this.particleDeathAge ) 
			{
				this.particleArray[i].alive = 0.0;
				recycleIndices.push(i);
			}
			// update particle properties in shader
     /*****************************START COMMENTED CODE***************/
     /*
        	this.particleMaterial.attributes.customVisible.value[i] = this.particleArray[i].alive;
			this.particleMaterial.attributes.customColor.value[i]   = this.particleArray[i].color;
			this.particleMaterial.attributes.customOpacity.value[i] = this.particleArray[i].opacity;
			this.particleMaterial.attributes.customSize.value[i]    = this.particleArray[i].size;
			this.particleMaterial.attributes.customAngle.value[i]   = this.particleArray[i].angle;
		
     */
     /*****************************FINISH COMMENTED CODE**************/		


       /*****************************START ADDED CODE***************/
      /*  this.customVisible.value[i]=  this.particleArray[i].alive; 
        this.customAngle.value[i]=  this.particleArray[i].angle;
        this.customSize.value[i]=  this.particleArray[i].size;
        this.customColor.value[i]=  this.particleArray[i].color;
        this.customOpacity .value[i]=  this.particleArray[i].opacity;

		
		this.particleGeometry.setAttribute('customVisible'+i, new BufferAttribute(this.customVisible.value[i], 1));
		this.particleGeometry.setAttribute('customAngle'+i, new BufferAttribute(this.customAngle.value[i], 1));
		this.particleGeometry.setAttribute('customSize'+i, new BufferAttribute(this.customSize.value[i], 1));
		this.particleGeometry.setAttribute('customColor'+i, new BufferAttribute(this.customColor.value[i], 3));
		this.particleGeometry.setAttribute('customOpacity'+i, new BufferAttribute(this.customOpacity.value[i], 1));
		*/
		this.particleGeometry.attributes.customVisible.array[i] = this.particleArray[i].alive;
			
		this.particleGeometry.attributes.customColor.array[(i*3)]= this.particleArray[i].color.r;
		this.particleGeometry.attributes.customColor.array[(i*3)+ 1]= this.particleArray[i].color.g;
		this.particleGeometry.attributes.customColor.array[(i*3)+ 2]= this.particleArray[i].color.b;

		this.particleGeometry.attributes.customOpacity.array[i] = this.particleArray[i].opacity;
		this.particleGeometry.attributes.customSize.array[i]    = this.particleArray[i].size;
		this.particleGeometry.attributes.customAngle.array[i]   = this.particleArray[i].angle;
     /*****************************FINISH ADDED CODE**************/
        }		
	}

	// check if particle emitter is still running
	if ( !this.emitterAlive ) return;

	// if no particles have died yet, then there are still particles to activate
	if ( this.emitterAge < this.particleDeathAge )
	{
		// determine indices of particles to activate
		var startIndex = Math.round( this.particlesPerSecond * (this.emitterAge +  0) );
		var   endIndex = Math.round( this.particlesPerSecond * (this.emitterAge + dt) );
		if  ( endIndex > this.particleCount ) 
			  endIndex = this.particleCount; 
			  
		for (var i = startIndex; i < endIndex; i++)
			this.particleArray[i].alive = 1.0;		
	}

	// if any particles have died while the emitter is still running, we imediately recycle them
	for (var j = 0; j < recycleIndices.length; j++)
	{
		/*var i = recycleIndices[j];
		this.particleArray[i] = this.createParticle();
		this.particleArray[i].alive = 1.0; // activate right away
		this.particleGeometry.attributes.position.array[(i*3)] =this.particleArray[i].position.x;
		this.particleGeometry.attributes.position.array[(i*3) + 1] =this.particleArray[i].position.y;
		this.particleGeometry.attributes.position.array[(i*3) + 2] =this.particleArray[i].position.z;*/
		var i = recycleIndices[j];
		this.particleArray[i] = this.createParticle();
		this.particleArray[i].alive = 1.0; // activate right away
		this.particleGeometry.attributes.position.array[(i*3)] =this.particleArray[i].position.x;
		this.particleGeometry.attributes.position.array[(i*3) + 1] =this.particleArray[i].position.y;
		this.particleGeometry.attributes.position.array[(i*3) + 2] =this.particleArray[i].position.z;
	}

	// stop emitter?
	this.emitterAge += dt;
	if ( this.emitterAge > this.emitterDeathAge )  this.emitterAlive = false;
}

ParticleEngine.prototype.destroy = function(scene)
{
	scene.remove( this.particleMesh );
	
}
///////////////////////////////////////ParticleEngineExamples.js FROM HERE////////////////////////////////////////




     /*****************************START ADDED CODE***************/
       var Examples =
{
     /*****************************FINISH ADDED CODE**************/


	
	// (1) build GUI for easy effects access.
	// (2) write ParticleEngineExamples.js
	
	// Not just any fountain -- a RAINBOW STAR FOUNTAIN of AWESOMENESS
	fountain :
	{
		
		positionStyle    : Type.CUBE,
		positionBase     : new Vector3( 0,  5, 0 ),
		positionSpread   : new Vector3( 10, 0, 10 ),
		
		velocityStyle    : Type.CUBE,
		velocityBase     : new Vector3( 0,  160, 0 ),
		velocitySpread   : new Vector3( 100, 20, 100 ), 

		accelerationBase : new Vector3( 0, -100, 0 ),
        /*****************************START ADDED CODE***************/
		particleTexture : new TextureLoader().load( 'images/star.png' ),
        /*****************************FINISH ADDED CODE**************/
        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/star.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/
		angleBase               : 0,
		angleSpread             : 180,
		angleVelocityBase       : 0,
		angleVelocitySpread     : 360 * 4,
		
		sizeTween    : new Tween( [0, 1], [1, 20] ),
		opacityTween : new Tween( [2, 3], [1, 0] ),
		colorTween   : new Tween( [0.5, 2], [ new Vector3(0,1,0.5), new Vector3(0.8, 1, 0.5) ] ),

		particlesPerSecond : 200,
		particleDeathAge   : 3.0,		
		emitterDeathAge    : 60
	},

	fireball :
	{
		positionStyle  : Type.SPHERE,
		positionBase   : new Vector3( 0, 50, 0 ),
		positionRadius : 2,
				
		velocityStyle : Type.SPHERE,
		speedBase     : 40,
		speedSpread   : 8,
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/smokeparticle.png' ),
        /*****************************FINISH ADDED CODE**************/
        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/smokeparticle.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/

		sizeTween    : new Tween( [0, 0.1], [1, 150] ),
		opacityTween : new Tween( [0.7, 1], [1, 0] ),
		colorBase    : new Vector3(0.02, 1, 0.4),
		blendStyle   : AdditiveBlending,  
		
		particlesPerSecond : 60,
		particleDeathAge   : 1.5,		
		emitterDeathAge    : 60
	},
	
	smoke :
	{
		positionStyle    : Type.CUBE,
		positionBase     : new Vector3( 0, 0, 0 ),
		positionSpread   : new Vector3( 10, 0, 10 ),

		velocityStyle    : Type.CUBE,
		velocityBase     : new Vector3( 0, 150, 0 ),
		velocitySpread   : new Vector3( 80, 50, 80 ), 
		accelerationBase : new Vector3( 0,-10,0 ),
        /*****************************START ADDED CODE***************/
		particleTexture :  new TextureLoader().load( 'images/smokeparticle.png'),
        /*****************************FINISH ADDED CODE**************/
		
        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/smokeparticle.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/		

		angleBase               : 0,
		angleSpread             : 720,
		angleVelocityBase       : 0,
		angleVelocitySpread     : 720,
		
		sizeTween    : new Tween( [0, 1], [32, 128] ),
		opacityTween : new Tween( [0.8, 2], [0.5, 0] ),
		colorTween   : new Tween( [0.4, 1], [ new Vector3(0,0,0.2), new Vector3(0, 0, 0.5) ] ),
		particlesPerSecond : 200,
		particleDeathAge   : 2.0,		
		emitterDeathAge    : 60
	},
	
	clouds :
	{
		positionStyle  : Type.CUBE,
		positionBase   : new Vector3( -100, 100,  0 ),
		positionSpread : new Vector3(    0,  50, 60 ),
		
		velocityStyle  : Type.CUBE,
		velocityBase   : new Vector3( 40, 0, 0 ),
		velocitySpread : new Vector3( 20, 0, 0 ), 
		
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/smokeparticle.png' ),
        /*****************************FINISH ADDED CODE**************/

        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/smokeparticle.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/
		sizeBase     : 80.0,
		sizeSpread   : 100.0,
		colorBase    : new Vector3(0.0, 0.0, 1.0), // H,S,L
		opacityTween : new Tween([0,1,4,5],[0,1,1,0]),

		particlesPerSecond : 50,
		particleDeathAge   : 10.0,		
		emitterDeathAge    : 60
	},
		
	snow :
	{
		positionStyle    : Type.CUBE,
		positionBase     : new Vector3( 0, 200, 0 ),
		positionSpread   : new Vector3( 500, 0, 500 ),
		
		velocityStyle    : Type.CUBE,
		velocityBase     : new Vector3( 0, -60, 0 ),
		velocitySpread   : new Vector3( 50, 20, 50 ), 
		accelerationBase : new Vector3( 0, -10,0 ),
		
		angleBase               : 0,
		angleSpread             : 720,
		angleVelocityBase       :  0,
		angleVelocitySpread     : 60,
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/snowflake.png' ),
        /*****************************FINISH ADDED CODE**************/

    /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/snowflake.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/			
		sizeTween    : new Tween( [0, 0.25], [1, 10] ),
		colorBase   : new Vector3(0.66, 1.0, 0.9), // H,S,L
		opacityTween : new Tween( [2, 3], [0.8, 0] ),

		particlesPerSecond : 200,
		particleDeathAge   : 4.0,		
		emitterDeathAge    : 60
	},
	
	rain :
	{
		positionStyle    : Type.CUBE,
		positionBase     : new Vector3( 0, 200, 0 ),
		positionSpread   : new Vector3( 600, 0, 600 ),

		velocityStyle    : Type.CUBE,
		velocityBase     : new Vector3( 0, -400, 0 ),
		velocitySpread   : new Vector3( 10, 50, 10 ), 
		accelerationBase : new Vector3( 0, -10,0 ),
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/raindrop2flip.png' ),
        /*****************************FINISH ADDED CODE**************/
    /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/raindrop2flip.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/	
		sizeBase    : 8.0,
		sizeSpread  : 4.0,
		colorBase   : new Vector3(0.66, 1.0, 0.7), // H,S,L
		colorSpread : new Vector3(0.00, 0.0, 0.2),
		opacityBase : 0.6,

		particlesPerSecond : 1000,
		particleDeathAge   : 1.0,		
		emitterDeathAge    : 60
	},
		
	starfield :
	{
		positionStyle    : Type.CUBE,
		positionBase     : new Vector3( 0, 200, 0 ),
		positionSpread   : new Vector3( 600, 400, 600 ),

		velocityStyle    : Type.CUBE,
		velocityBase     : new Vector3( 0, 0, 0 ),
		velocitySpread   : new Vector3( 0.5, 0.5, 0.5 ), 
		
		angleBase               : 0,
		angleSpread             : 720,
		angleVelocityBase       : 0,
		angleVelocitySpread     : 4,
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/spikey.png' ),
        /*****************************FINISH ADDED CODE**************/
		
		    /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/spikey.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/	
		sizeBase    : 10.0,
		sizeSpread  : 2.0,				
		colorBase   : new Vector3(0.15, 1.0, 0.9), // H,S,L
		colorSpread : new Vector3(0.00, 0.0, 0.2),
		opacityBase : 1,

		particlesPerSecond : 20000,
		particleDeathAge   : 60.0,		
		emitterDeathAge    : 0.1
	},

	fireflies :
	{
		positionStyle  : Type.CUBE,
		positionBase   : new Vector3( 0, 100, 0 ),
		positionSpread : new Vector3( 400, 200, 400 ),

		velocityStyle  : Type.CUBE,
		velocityBase   : new Vector3( 0, 0, 0 ),
		velocitySpread : new Vector3( 60, 20, 60 ), 
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/spark.png' ),
        /*****************************FINISH ADDED CODE**************/		
        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/spark.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/

		sizeBase   : 30.0,
		sizeSpread : 2.0,
		opacityTween : new Tween([0.0, 1.0, 1.1, 2.0, 2.1, 3.0, 3.1, 4.0, 4.1, 5.0, 5.1, 6.0, 6.1],
		                         [0.2, 0.2, 1.0, 1.0, 0.2, 0.2, 1.0, 1.0, 0.2, 0.2, 1.0, 1.0, 0.2] ),				
		colorBase   : new Vector3(0.30, 1.0, 0.6), // H,S,L
		colorSpread : new Vector3(0.3, 0.0, 0.0),

		particlesPerSecond : 20,
		particleDeathAge   : 6.1,		
		emitterDeathAge    : 600
	},
	
	startunnel :
	{
		positionStyle  : Type.CUBE,
		positionBase   : new Vector3( 0, 0, 0 ),
		positionSpread : new Vector3( 10, 10, 10 ),

		velocityStyle  : Type.CUBE,
		velocityBase   : new Vector3( 0, 100, 200 ),
		velocitySpread : new Vector3( 40, 40, 80 ), 
		
		angleBase               : 0,
		angleSpread             : 720,
		angleVelocityBase       : 10,
		angleVelocitySpread     : 0,
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load('images/spikey.png' ),
        /*****************************FINISH ADDED CODE**************/		
	        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture('images/spikey.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/


		sizeBase    : 4.0,
		sizeSpread  : 2.0,				
		colorBase   : new Vector3(0.15, 1.0, 0.8), // H,S,L
		opacityBase : 1,
		blendStyle  : AdditiveBlending,

		particlesPerSecond : 500,
		particleDeathAge   : 4.0,		
		emitterDeathAge    : 60
	},

	firework :
	{
		positionStyle  : Type.SPHERE,
		positionBase   : new Vector3( 0, 100, 0 ),
		positionRadius : 10,
		
		velocityStyle  : Type.SPHERE,
		speedBase      : 90,
		speedSpread    : 10,
		
		accelerationBase : new Vector3( 0, -80, 0 ),
		
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/spark.png' ),
        /*****************************FINISH ADDED CODE**************/		
	
		        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/spark.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/
		sizeTween    : new Tween( [0.5, 0.7, 1.3], [5, 40, 1] ),
		opacityTween : new Tween( [0.2, 0.7, 2.5], [0.75, 1, 0] ),
		colorTween   : new Tween( [0.4, 0.8, 1.0], [ new Vector3(0,1,1), new Vector3(0,1,0.6), new Vector3(0.8, 1, 0.6) ] ),
		blendStyle   : AdditiveBlending,  
		
		particlesPerSecond : 3000,
		particleDeathAge   : 2.5,		
		emitterDeathAge    : 0.2
	},

    candle :
	{
		positionStyle  : Type.SPHERE,
		positionBase   : new Vector3( 0, 50, 0 ),
		positionRadius : 2,
		
		velocityStyle  : Type.CUBE,
		velocityBase   : new Vector3(0,100,0),
		velocitySpread : new Vector3(20,0,20),
		
        /*****************************START ADDED CODE***************/
		particleTexture :new TextureLoader().load( 'images/smokeparticle.png' ),
        /*****************************FINISH ADDED CODE**************/
        /*****************************START COMMENTED CODE***************/
         /*
            particleTexture : THREE.ImageUtils.loadTexture( 'images/smokeparticle.png' ),
         */
         /*****************************FINISH COMMENTED CODE**************/
		sizeTween    : new Tween( [0, 0.3, 1.2], [20, 150, 1] ),
		opacityTween : new Tween( [0.9, 1.5], [1, 0] ),
		colorTween   : new Tween( [0.5, 1.0], [ new Vector3(0.02, 1, 0.5), new Vector3(0.05, 1, 0) ] ),
		blendStyle : AdditiveBlending,  
		
		particlesPerSecond : 60,
		particleDeathAge   : 1.5,		
		emitterDeathAge    : 60
	}
	
}
        /*****************************START ADDED CODE***************/
		export{Examples, ParticleEngine}
        /*****************************FINISH ADDED CODE**************/

